#!/usr/bin/env python
# Copyright (c) 2010 Cloudera, inc.
# https://wiki.cloudera.com/display/PRODUCT/Staging+step

import boto
import datetime
import getpass
import logging
import subprocess
import sys
import time
from optparse import OptionParser
from sets import Set

import cloudera.aws.ec2
import cloudera.staging.ElasticIpManager
import cloudera.staging.StageManager
import cloudera.staging.Archive
import cloudera.staging.ArchiveManager
from cloudera.utils import display_message, verbose_print, make_target_to_product_name
from cloudera.constants import RepositoryType


TIMEOUT = '240'
FREEZER_SCRIPT = './freezer'
class ErrorEncountered(Exception):
  ''' A null exception wrapper '''
  pass


def get_build_name():
  '''
  Generate a build name with a timestamp
  @return Generated build name
  '''
  build_time = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S") 
  return 'nightly_%s_' % (build_time, )


def make_cdh(product_names, version='2', maven_deploy_flag="deploy"):
  '''
  Call make for the given products
  @param product_names Array of product names such as pig or hive
  @param version CDH version to build for
  @param Maven deploy flag - either "deploy" or "".
  @return Return code
  '''
  # We always build hadoop
  products = ['hadoop20', 'hadoop20-sdeb', 'hadoop20-srpm', 'hadoop20-relnotes']
  for product_name in product_names:
    products.append(product_name)
    for suffix in ['-sdeb', '-srpm']:
      products.append(product_name + suffix)

  display_message("Crepo sync CDH" + version)
  crepo_sync_cmd = ['crepo', '-m', '../../cdh' + version + '.json', 'sync']
  crepo_returncode = subprocess.Popen(crepo_sync_cmd).wait()

  if crepo_returncode != 0:
    raise ErrorEncountered("Crepo failed to sync repositories")

  failed_products = Set()
  display_message("Make CDH" + version)
  for product in products:
    p = subprocess.Popen(['make', 'CDH=cdh'+version, 'DO_MAVEN_DEPLOY='+maven_deploy_flag, product], cwd='../../')
    p.wait()

    if p.returncode != 0:
      # product is a Makefile target such as zookeeper-srpm, so we need to
      # extract the real product name
      original_product_name = make_target_to_product_name(product)
      failed_products.add(original_product_name)

  # Returns a list of failed products
  return [product for products in failed_products]

def build_cdh(product_names,
		build_bucket,
		key_name,
		version='2',
		build_name_base = ''):
  '''
  Call ec2build to build our products for various platforms
  @param product_names Product names to be built
  @param key_name EC2 key name
  @param version CDH version to build for
  @param build_name_base Build name base
  @return build name
  '''
  buildname = build_name_base + version

  products = ['-p', 'hadoop20']
  for product_name in product_names:
    products = products + ['-p', product_name]

  command = ['./ec2_build',
       '-w',
       '-k', key_name,
       '-b', build_bucket,
       '--tag', 'cdh'+version,
       '--timeout', TIMEOUT,
       '--build_id', buildname]

  p = subprocess.Popen(command + products)
  p.wait()
  if p.returncode != 0:
    raise ErrorEncountered("Could not build CDH")

  return buildname

def freeze_cdh(build_bucket,
		cloudera_freezer,
		version='2',
		build_name_base = ''):
  '''
  Freeze cdh build
  @param version CDH version to build for
  @param build_name_base Build name base
  @return build name
  '''
  buildname = build_name_base + version
  p = subprocess.Popen([FREEZER_SCRIPT, buildname, buildname,
		  '-b' , build_bucket,
		  '-f' , cloudera_freezer])

  freezer_returncode = p.wait()

  if freezer_returncode != 0:
    raise ErrorEncountered("Could not freeze build")

  return buildname


def freeze_hue(cloudera_freezer, version='3', build_name_base = ''):
  '''
  Freeze hue build Which is currently superate
  @param version CDH version to build for
  @param build_name_base Build name base
  @return build name
  '''
  buildname = build_name_base + version
  hue_bucket = 'hue-build'
  freezer_cmd = [FREEZER_SCRIPT, '-b', hue_bucket, '-f', cloudera_freezer]
  p = subprocess.Popen(freezer_cmd + [buildname, buildname])
  freezer_returncode = p.wait()

  if freezer_returncode != 0:
    sys.stderr.write("ERROR: Could not freeze hue\n")

  return buildname


def get_free_eip(eip_manager):
  '''
  Get a free Elastic IP
  '''

  return eip_manager.get_first_available_ip()


def boot_ami(archive_manager, options):
  '''
  Boot a new AMI

  @return Return a tuple (Instance, Hostname)
  '''

  display_message("Boot AMI")

  instance = archive_manager.kickOff(options.snapshot,
		  options.security_group_name,
		  options.security_group_desc,
		  options.key_name,
		  options.ami)

  if not instance:
    raise ErrorEncountered("Couldn't boot ami")

  hostname = instance.public_dns_name
  if not hostname:
    raise ErrorEncountered("Unknown hostname for newly started instance")

  return instance, hostname


def update_archive(build,
		key_file,
		hostname,
		passphrase_apt,
		passphrase_yum,
		cdh_version,
		freezer_bucket):
  '''
  Update an archive

  @param build Build to de staged
  @param key_file SSH private key filename
  @param hostname Hostname of the archive
  @param passphrase Passphrase used for signing packages
  '''

  display_message("Update newly started instance")
  log_handler = logging.StreamHandler()
  logging.getLogger("paramiko.transport").addHandler(log_handler)

  archive = cloudera.staging.Archive.Archive()

  # Set up instance
  archive.connect(hostname, key_file)
  archive.copy_scripts(hostname, key_file)
  archive.install_packages()
  archive.setup_gpg()

  # Set up gpg-agent for Apt repos
  if passphrase_apt:
    apt_fingerprint = cloudera.utils.gpg_key_fingerprint(RepositoryType.APT)
    archive.start_gpg(RepositoryType.APT)
    archive.get_gpg_env(RepositoryType.APT)
    archive.set_gpg_passphrase(apt_fingerprint, passphrase_apt)

  # Update Apt repos
  archive.update_deb_repo(build, cdh_version, freezer_bucket)

  # Set up gpg-agent for Yum repos
  if passphrase_yum:
    yum_fingerprint = cloudera.utils.gpg_key_fingerprint(RepositoryType.YUM)
    archive.start_gpg(RepositoryType.YUM)
    archive.get_gpg_env(RepositoryType.YUM)
    archive.set_gpg_passphrase(yum_fingerprint, passphrase_yum)

  # Update Yum repos
  archive.update_yum_repo(build, cdh_version)

  # Finalize staging
  archive.finalize_staging(build, cdh_version)
  archive.clean_up()


def main():
  ''' Main loop '''
  usage = "usage: %prog  [options] <snap_id> a lot"
  op = OptionParser(usage=usage)
  op.add_option('-d', '--dry-run',
              action="store_true",
              default=False,
              help="Dont do anything just pretend")

  op.add_option('-c', '--cdh-version',
            help="CDH version")

  op.add_option('-k', '--key-file',
            help="The key file authorized")

  op.add_option('-n', '--key-name',
            help="The keyname authorized")

  op.add_option('--passphrase-apt',
            help="Passphrase used for APT packages")

  op.add_option('--passphrase-yum',
            help="Passphrase used for YUM packages")

  op.add_option('--build-bucket',
            default='ec2-build',
            help="Where we should drop the build")

  op.add_option('--freezer-bucket',
            default='cloudera-freezer',
            help="An alternative Cloudera, inc. freezer bucket")

  default_build_name = get_build_name()
  op.add_option('-b', '--build',
            default=default_build_name,
            help="The build to deploy")

  op.add_option('--snapshot',
            help="Snapshot to base staging from")

  default_sec_group_desc = 'Open HTTP for Cloudera and SSH for everyone'
  op.add_option('-i', '--security-group-desc',
     default=default_sec_group_desc,
     help="Override the default security group Description")

  build_time = time.strftime('%Y%m%d_%H%M%S', time.gmtime())
  default_sec_group_name = 'Build-Artifact-%s' % (build_time, )
  op.add_option('-g',
		  '--security-group-name',
		  default=default_sec_group_name,
		  help="Override the default security group name")

  ami = cloudera.staging.ArchiveManager.ArchiveManager.DEFAULT_AMI
  op.add_option('-a', '--ami', default=ami,
    help="The alternative ami to boot: %s"  % ami)

  default_product_names = []
  op.add_option('--product-names',
    default=default_product_names,
    action='append',
    help="Products to be built (ex: pig, hive, oozie, hbase)")

  op.add_option('--gpg-sign',
      action="store_true",
      default=None,
      help="Sign deployed packages")

  op.add_option('-p', '--promote',
      action="store_true",
      default=False,
      help="Promote instance as official archive")

  op.add_option('--no-maven-deploy',
      action="store_true",
      default=False,
      help="Skip deploy of Maven artifacts to repository.cloudera.com")

  (options, args) = op.parse_args()

  if not options.cdh_version:
    op.error('--cdh-version option is mandatory')

  if not options.build:
    op.error('build option is mandatory')

  if not options.snapshot:
    op.error('snapshot option is mandatory')

  if not options.key_file:
    op.error('key-file option is mandatory')

  if not options.key_name:
    op.error('key-file option is mandatory')

  product_names = options.product_names

  # XXX reprepo seems to insist on signing packages. 
  # Haven't found a work around yet
  if not options.gpg_sign:
    op.error('Staging without signing packages is not supported yet. Please add the option --gpg-sign')

  # Get pass phrase first so user doesn't have to wait
  passphrase_apt = options.passphrase_apt
  passphrase_yum = options.passphrase_yum

  if options.gpg_sign:
    prompt = "Please, enter gpg passphrase for %s repository: "
    if not passphrase_apt:
      passphrase_apt = getpass.getpass(prompt % ("Apt",))

    if not passphrase_yum:
      passphrase_apt = getpass.getpass(prompt % ("Yum",))

  # If --no-maven-deploy was given, set maven_deploy_flag to "" - otherwise, set it to "deploy".
  maven_deploy_flag = "deploy"
  if options.no_maven_deploy:
    maven_deploy_flag = ""

  ec2_connection  = boto.connect_ec2()

  eip_manager = cloudera.staging.ElasticIpManager.ElasticIpManager()
  stage_manager = cloudera.staging.StageManager.StageManager()
  archive_manager = cloudera.staging.ArchiveManager.ArchiveManager(ec2_connection)


  build_names = []
  for version in ['3']:
    failed_products = make_cdh(product_names, version, maven_deploy_flag)

    # failed_products will contain all the targets for a given products, including the product name
    # For example flume as well as flume-srpm and flume-sdeb
    product_names = [product_name for product_name in product_names if not product_name in failed_products]

    build_cdh_prompt = build_cdh(product_names,
		    options.build_bucket,
		    options.key_name,
		    version,
		    options.build)

    build_names.append((version, build_cdh_prompt))
    freeze_cdh(options.build_bucket,
		    options.freezer_bucket,
		    version,
		    options.build)
    if version == 3:
      freeze_hue(options.freezer_bucket, 3, options.build)

  eip = get_free_eip(eip_manager)


  if not eip:
    raise ErrorEncountered("No Elastic IP available")
  display_message("Free IP address found: %s"%(eip.public_ip))

  # Boot an instance
  instance, hostname =  boot_ami(archive_manager, options)


  display_message("Updating records about instance id and elastic ip address")
  stage_manager.add_instance(instance_id=instance.id, user=getpass.getuser(), security_group=options.security_group_name)


  display_message("Associating IP with instance: %s -> %s" % (eip.public_ip, instance.id))
  ec2_connection.associate_address(instance.id, eip.public_ip)

  verbose_print("Waiting for the address to be effectively associated...")
  cloudera.aws.ec2.wait_for_eip_association_ready()
  for (version, build_name) in build_names:
    update_archive(build_name,
		    options.key_file,
		    eip.public_ip,
		    passphrase_apt,
		    passphrase_yum,
		    options.cdh_version,
		    options.freezer_bucket)

  if options.promote:
    # Make this archive become the official one
    old_nightly = archive_manager.promote_nightly(instance, eip.public_ip)

    if old_nightly:
      old_nightly_instance = cloudera.aws.ec2.instance_for_instance_id(ec2_connection, old_nightly)
      archive_manager.tear_down_archive(old_nightly_instance)

  if failed_products:
    display_message("The following products failed to build: %s" % (str(failed_products)))

main()
